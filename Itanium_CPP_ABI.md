##英特尔安腾处理器C++ ABI

###内容
+ 致谢

+ 第一章：简介
	* 1.1 定义
	* 1.2 限制 
	* 1.3 命名空间和头文件
	* 1.4 ABI的范围
	* 1.5 文档基础说明		
+ 第二章：数据布局
	* 2.1 概况
	* 2.2 POD 数据类型
	* 2.3 成员指针
	* 2.4 非 POD 类 类型 WEIFIXME
	* 2.5 虚表布局
	* 2.6 对象构造期间的虚表
	* 2.7 数组new的操作指南
	* 2.8 初始化Guard变量
	* 2.9 运行时类型信息(RTTI)
+ 第三章：函数调用的规范和API
	* 3.1 非虚函数的调用规范
	* 3.2 虚函数的调用规范
	* 3.3 构造和西沟的API
	* 3.4 命名修饰的逆向
+ 第四章： 异常处理
+ 第五章： 链接和目标文件
	* 5.1 外部名称(又称：命名修饰)
	* 5.2 模糊链接
	* 5.3 Unwind Table Location
+ 附录 R：修订历史

<hr>

###致谢
WEIFIXME

<hr>

###第一章：简介
在这篇文档中，我们详细描述了C++程序的ABI(Application Binary Interface), 即：用户C++代码和提供实现的系统、库之间的对象代码接口。 这包含了C++数据对象(预定义的和用户自定义的数据类型)的内存布局，还有编译器生成的对象，例如虚表。除此之外，文档还讲述了函数调用接口，异常处理，全局命名和各种各样的目标代码的约定。

总的来说， 这篇文档是给在多种架构上实现C++的时候所使用的一份通用的规格说明书。此外它也包含了奔腾64位ABI的处理器相关的材料。当我们描述结构化数据布局的时候，我通常情况下使用size表示成员大小。通过适当的修改size的大小即可切换到32位的ABI的实现(例如：指针和长整型变成32位)， 但是有时候成员间声明顺序的变化可能需要数据紧凑排布，我们需要更加关注更本质的变化。

<hr>

####1.1 定义
文档的描述使用了下面的定义：

 * 直接基类顺序
 
 	当某个类的基类被看成一个有序集合的时候，直接基类顺序即按照声明的顺序，从左往右。
 * 动态类
 	
 	某个类需要虚表指针(它或者它的基类有若干个虚成员函数 或者 虚基类)
 * 空类
 
 	某个类除了静态数据成员(可以也没有)之外，没有虚函数，没有虚基类，没有非空非虚的合理基类。
 * 内存布局的POD
 
 	通常来说， 如果一个类型在C++标准看来是一个POD类型，它就被认为是内存布局意义上的POD。然而POD-struct/union(C++标准)，如果它们有个位域数据成员声明时的宽度比declared type of the bitfield， 那么它就不能称为内存布局POD。




































 





